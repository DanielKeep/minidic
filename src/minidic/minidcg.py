
from sit import *
from writer import Writer


class CGState(object):

    o = None

    module = None

    def __init__(self, writer):
        self.o = writer



class CGSemVisitor(SemVisitor):

    targetPath = None
    package = None

    def __init__(self):
        super(CGSemVisitor, self).__init__()


    def defaultVisit(self, node, st):
        assert False, "unimplemented visit for %r" % node


    def unimpl(self, node, st):
        st.o.fl("/* unimplemented %s */", type(node).__name__)


    def visitSemModule(self, node, st):
        (st.o
         .pl("/* Generated by minidic */")
         .fl("module %s.%s;", self.package, node.fqi)
         .l()
         .fl('static import %s;', node.fqi)
         .pl('static import md = minid.api;')
         .pl('static import mdu = minid.util;')
         .pl('static import mdi = minidic.binding;')
         .l()
         )

        self.generateModuleInit(node, st)

        st.module = node

        for decl in node.decls:
            self.visit(decl, st)


    def visitSemImportDecl(self, node, st):
        (st.o
         .fl('import %s.%s : MD_%s;', self.package, node.module, node.symbol)
         )


    def visitSemConstDecl(self, node, st):
        self.unimpl(node, st)


    def visitSemClassDecl(self, node, st):
        self.generateAggregate(node, st)


    def generateAggregate(self, node, st):
        class_fqn = st.module.fqi + '.' + node.ident
        is_class = isinstance(node, SemClassDecl)
        
        (st.o
         .fl('struct MD_%s', node.ident)
         .push('{')
         .pop().fl('static:').push()
         .fl('const Name = "%s";', node.ident)
         .fl('const FQName = "%s";', class_fqn)
         .l()
         .fl('/// Reference to the MiniD class')
         .fl('ulong classRef = ulong.max;')
         .l()
         )
        
        if is_class:
            (st.o
             .fl('enum : bool { WrapStruct = false }')
             .fl('alias %s RawWrapRef;', class_fqn)
             .fl('alias %s Wrap;', class_fqn)
             )
        else:
            (st.o
             .fl('enum : bool { WrapStruct = true }')
             .fl('alias %s* RawWrapRef;', class_fqn)
             .fl('alias StructBox!(%s) Wrap;', class_fqn)
             )
            
        (st.o
         .l()
         )

        # init
        (st.o
         .pl('void init(md.MDThread* t)')
         .push('{')
         .pl('md.CreateClass(t, FQName, (md.CreateClass* c)')
         .push('{')
         .pl('c.method("constructor", &constructor);')
         )
        self.generateInitMethodBinds(node, st)
        (st.o
         .pop('});')
         .l()
         .pl('md.newFunction(t, &allocator, "allocator");')
         .pl('md.setAllocator(t, -2);')
         .l()
         .pl('classRef = md.createRef(t, -1);')
         .pl('assert( classRef != classRef.max );')
         .l()
         .pl('md.newGlobal(t, Name);')
         .pop('}')
         .l()
         )
        
        # initModule
        (st.o
         .pl('void init(md.MDThread* t)')
         .push('{')
         .pl('if( classRef == classRef.max )')
         .push().pl('init(t);').pop()
         .l()
         .pl('md.pushRef(t, classRef);')
         .pl('md.newGlobal(t, Name);')
         .pop('}')
         .l()
         )
        
        # TODO: checkInstParam
        # TODO: getWrap
        # TODO: setWrap
        # TODO: pushPtr
        # TODO: popValue
        # TODO: create (slot)
        # TODO: create (RawWrapRef)
        # TODO: create (slot, RawWrapRef, hasArgs)
        # TODO: allocator
        # TODO: constructor

        for decl in node.decls:
            if decl.ident == "this":
                continue

            self.visit(decl, st)

        (st.o
         .pop('}')
         )


    def visitSemStructDecl(self, node, st):
        self.unimpl(node, st)


    def visitSemRoDecl(self, node, st):
        self.unimpl(node, st)


    def visitSemRwDecl(self, node, st):
        self.unimpl(node, st)


    def visitSemFuncDecl(self, node, st):
        self.unimpl(node, st)


    def visitSemOpDecl(self, node, st):
        self.unimpl(node, st)


    def visitSemMixin(self, node, st):
        st.o.r(node.code)


    def generateModuleInit(self, node, st):
        (st.o
         .pl('struct MD_Module')
         .push('{')
         .pop().pl('static:').push()
         .pl('void init(MDThread* t)')
         .push('{')
         )

        for decl in node.decls:
            if isinstance(decl, SemMixin): continue
            if isinstance(decl, SemImportDecl): continue
            st.o.fl('MD_%s.init(t);', decl.ident)
        
        (st.o
         .l()
         .fl('md.makeModule(t, "%s", function uword(MDThread* t,'
             +' uword numParams)', node.fqi)
         .push('{')
         )

        for decl in node.decls:
            if isinstance(decl, SemMixin): continue
            if isinstance(decl, SemImportDecl): continue
            st.o.fl('MD_%s.initModule(t);', decl.ident)
        
        (st.o
         .pl('return 0;')
         .pop('});')
         .pop('}')
         .pop('}')
         .l()
         )


    def generateInitMethodBinds(self, node, st):
        for decl in node.decls:
            if decl.ident == "this": continue

            if isinstance(decl, SemMixin):
                # do nothing
                pass

            elif isinstance(decl, SemOpDecl):
                st.o.fl('/* unimplemented init method bind for op %s */', decl.ident)

            else:
                st.o.fl('c.method("%s", &method_%s);', decl.ident, decl.ident)


